---
title: "Assignment"
subtitle: "Option Pricing and Risk - Financial Statistics"
author: "Alexander J Ohrt"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    theme: readable
    highlight: textmate
    number_sections: true
  pdf_document:
    fig_caption: true
    number_sections: true
    toc: false
editor_options: 
  chunk_output_type: console
geometry:
  margin = 2.2cm
urlcolor: blue
linkcolor: black
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = T, warning = F, fig.width = 10, comment = "#>", size = "scriptsize")
setwd("/home/ajo/gitRepos/finance/part1")
library(ggplot2)
library(tidyverse)
```

# Problem A - Euler-Maruyama Method

First we implement a discretization for the Black-Scholes-Merton price dynamics with the given parameter set, with $n = 250$ steps. We generate $M_1 = 10$, $M_2 = 100$, $M_3 = 1000$, $M_4 = 10000$ and $M_5 = 100000$ paths and plot the paths in separate figures. 

```{r}
set.seed(061999)
s0 <- 12
T1 <- 1
mu <- 0.03
sigma <- 0.17
n <-  250
t <- seq(0, T1, length.out = n)
M1 <- 10
M2 <- 100
M3 <- 1000
M4 <- 10000
M5 <- 100000
```

```{r}
# Price path stochastic process. 
price.path <- function(s0, t, mu, sigma){
  W <- rnorm(n = length(t), mean = 0, sd = t)
  s0*exp(mu*t)*exp(sigma*W-sigma^2/2*t)
}
```

```{r}
#plot(NULL, NULL, main = paste0(M1," paths"), xlim = c(0,1), ylim = c(0, 50), ylab = "S", xlab = "t")
M1.paths <- matrix(rep(NA, length.out = M1*n), nrow = M1)
for (i in 1:M1){
  M1.paths[i,] <- price.path(s0, t, mu, sigma)
}
#lines(M1.paths, col = 1:M1)
#df1 <- tibble(M1.paths)
#df1 %>% ggplot()

# Burde lage denne plotting bedre med ggplot senere kanskje!
# Endre til tid på x-aksen også kanskje!
matplot(t(tibble(M1.paths)), type = "l", main = paste0(M1," paths"), xlab = "Discretization Points", ylab = "S")
```

```{r}
#plot(NULL, NULL, main = paste0(M1," paths"), xlim = c(0,1), ylim = c(0, 50), ylab = "S", xlab = "t")
M2.paths <- matrix(rep(NA, length.out = M2*n), nrow = M2)
for (i in 1:M2){
  M2.paths[i,] <- price.path(s0, t, mu, sigma)
}
#lines(M1.paths, col = 1:M1)
#df2 <- tibble(M2.paths)
#df1 %>% ggplot()

# Burde lage denne plotting bedre med ggplot senere kanskje!
# Endre til tid på x-aksen også kanskje!
#M2.p <- tibble(M2.paths)
matplot(M2.paths, type = "l", main = paste0(M2," paths"), xlab = "Discretization Points", ylab = "S")
lines(t, apply(M2.paths, 2, mean), cex = 2)
```

Dette skal gjøres for alle verdiene for M over! (gjør etter at plottingen er fikset!)

TESTING CODE BELOW COMPARING TO SLIDE 33. Tror noe er galt!

```{r}
n2 <- 100
Mtest.paths <- matrix(rep(NA, length.out = M1*n2), nrow = M1)
for (i in 1:M1){
  Mtest.paths[i,] <- price.path(10, seq(0, 5, length.out = n2), 
                                0.05, 0.05)
}
#lines(M1.paths, col = 1:M1)
#df2 <- tibble(M2.paths)
#df1 %>% ggplot()

# Burde lage denne plotting bedre med ggplot senere kanskje!
# Endre til tid på x-aksen også kanskje!
matplot(t(tibble(Mtest.paths)), type = "l", main = paste0(M1," paths"), xlab = "Discretization Points", ylab = "S", ylim = c(0,20))
```

ÅPENBART AT NOE ER GALT HER!

Prøvde å få denne til å ligne på plot på slide 33 i Section 2.2, men mine paths varierer veldig mye! Tror det er noe galt i koden for pathsene muligens!!

The Monte Carlo estimator for $\hat{S}_T$ is calculated separately for each of the values of $M_i$. The 5\% confidence interval is provided for each estimator. A comparison between these estimators and the analytical solution of $\mathbb{E}(S_T)$ (seen above) is done and differences are explained. 

# Problem B - Option Pricing I

```{r}
set.seed(061999)
s0 <- 24
T1 <- 1.5
r <- 0.02
sigma <- 0.22
K <- 23.5
```


```{r, eval = F}
# BSM pricing formula for European call option, 
# to calculate the fair price at t = 0 in closed form.
BSM <- function(s0, T1, r, sigma, K){
  d1 <- (log(s0/K)+(r+sigma^2/2)*T1)/(sigma*sqrt(T1))
  d2 <- d1 - sigma*sqrt(T1)
  s0*pnorm(d1) - exp(-r*T1)*K*pnorm(d2)  
}
```

```{r}
# Exercises on slide 45
# Call price
BSM(s0 = 20, K = 18, T1 = 1, r = 0.05, sigma = 0.2)
# Put price
BSM(s0 = 20, K = 18, T1 = 1, r = 0.05, sigma = 0.2)-20+exp(-0.05*1)*18

# Call price
BSM(s0 = 20, K = 18, T1 = 1, r = 0.05, sigma = 0.2)
# Put price
BSM(s0 = 20, K = 18, T1 = 1, r = 0.05, sigma = 0.2)-20+exp(-0.05*1)*18
```


We calculate the price of the given Call option (parameters are given in code block above) with the Black-Scholes-Merton formula.

```{r}
BSM.price <- BSM(s0, T1, r, sigma, K)
```

As we can see, the price is approximately equal to `r round(BSM.price, 2)`, when rounded to 2 decimals. 

We implement a Monte Carlo estimator for this option price by simulation paths with the Euler-Maruyama method for given steps and paths. 

Notice that for the path-independent options, like standard European call and put options, it is not needed to save the price path as is done below. This is done to keep the function as general as possible, in order to re-use it for the rest of the assignment. THIS COULD EASILY BE CHANGED IN THIS CASE IF TOO SLOW! (simply overwriting the previous value in the loop in every iteration).

```{r}
# Monte Carlo estimator for Euler-Maruyama. 
# This is for a Call option still (almost general) (slide 28)
MC <- function(M, n, r, s0, mu, h, sigma, T1, payoff.profile, set.S, ...){
  C.values <- rep(NA, length.out = M) # Initiate vector for saving payoffs per path. 
  for (i in 1:M){ # Initiate loop for M path.
    Z <- rnorm(n) # Generate n random variables standard normally. 
    S.values <- rep(NA, length.out = n+1) # Initiate vector for saving price path. 
    S.values[1] <- s0 # Initiate starting price at time t = 0. 
    for (j in 2:(n+1)){ # Loop for Euler-Maruyama - recursively estimate price path. 
      S.values[j] <- S.values[j-1] + mu*S.values[j-1]*h + sigma*S.values[j-1]*sqrt(h)*Z[j-1]
    }
    S <- set.S(S.values, n) # Set expected price used in payoff-profile. 
    # Generality is kept using a helper function set.S.
    C.values[i] <- payoff.profile(S, K) # Calculate payoff for the path and save in C.values.
  }
  exp(-r*T1)*mean(C.values) # Return discounted average payoff. This is the MC estimator. 
}
```

```{r}
# Definition of helper functions to feed into MC estimator code above. 
Call.profile <- function(S, K){
  max(0, S-K)
}

# Feed the function into the MC estimator in order to calculate estimate for Call option. 
Call.set.S <- function(S.values){
  S.values[length(S.values)] # The Call option uses the last value in the list. 
}
```

```{r}
# Simulate paths with the MC estimator and Euler-Maruyama. 
# mu = 0? h = 1? Helt sikkert feil! Den må nok avgjøres basert på diskretiseringen (dvs steglengden er h tror jeg)
MC(10, 10, r, s0, mu = 0, h = 1, sigma, T1, Call.profile, Call.set.S, K = K)
```


```{r}
# Calculations of relative error and absolute error.
```

TESTER MED EKSEMPLER I SLIDES!

```{r}
# slide 21 Section 3
mu <- 0.05
sigma <- 0.2
s0 <- 10
T1 <- 1
n <- 5
h <- 1/n

Z <- rnorm(n)
Z <- c(0.5377, 1.8339, -2.2588, 0.8622, 0.3188)
S.values <- rep(NA, length.out = n+1)
S.values[1] <- s0
for (j in 2:(n+1)){
  S.values[j] <- S.values[j-1] + mu*S.values[j-1]*h + sigma*S.values[j-1]*sqrt(h)*Z[j-1]
}
S.values
S.values[length(S.values)]
# Correct!
# This means that the inner loop with the Euler Method is correctly implemented at least!
```

```{r}
MC <- function(M, n, r, s0, mu, h, sigma, T1, payoff.profile, set.S, ...){
  C.values <- rep(NA, length.out = M)
  for (i in 1:M){
    Z <- rnorm(n)
    S.values <- rep(NA, length.out = n+1)
    S.values[1] <- s0
    for (j in 2:(n+1)){
      S.values[j] <- S.values[j-1] + mu*S.values[j-1]*h + sigma*S.values[j-1]*sqrt(h)*Z[j-1]
    }
    S <- set.S(S.values, n) # Generality is kept using a helper function set.S.
    C.values[i] <- payoff.profile(S, K)
  }
  exp(-r*T1)*mean(C.values) # Return discounted average payoff
}
```


# Problem C - Option Pricing II

A Monte Carlo estimator is implemented for a specific Asian Call Option. 

```{r}
set.seed(061999)

# This function can be fed into the MC estimator instead. 
Asian.set.S <- function(S.values){
  # Average prices every friday. 
  # I think it still uses the same Call.profile (perhaps this function is not needed after all!)
}
```
