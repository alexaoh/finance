---
title: "NASDAQ Composite"
subtitle: "Trabajo Final - Modelos de Volatilidad - Financial Statistics"
author: "Alexander J Ohrt"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_depth: 3
    theme: readable
    highlight: textmate
    number_sections: true
  pdf_document:
    fig_caption: true
    number_sections: true
    
editor_options: 
  chunk_output_type: console
geometry:
  margin = 2.5cm
urlcolor: blue
---

\tableofcontents
\newpage

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE, warning = F, fig.width = 10, comment = "#>")
setwd("/home/ajo/gitRepos/finance")
library(quantmod)
library(fBasics)
library(urca)
library(forecast)
library(rugarch)
library(fTrading)
library(latex2exp)
```

# Abstract
The mean and conditional variance of the NASDAQ Composite index are modelized. The work shows that ...

MAKE REFERENCES BETWEEN PLOTS (NUMBERS AND CITATIONS IN TEXT, bookdown is necessary maybe?) LATER. 

\newpage
# Introduction 
Describe

* Scenario and objective of the work. What will be analyzed. 
* Precise description of variable (NASDAQ Composite) used in the analysis and description of where the data is gathered from (Yahoo Finance)
* Summary of structure of the work (description of what is done in each part)

The data is gathered directly from Yahoo Finance and can be found [here](https://finance.yahoo.com/quote/%5EIXIC?p=%5EIXIC).

\newpage
# Empirical Application

## Load Data 
First, we load the NASDAQ Composite data from Yahoo Finance.

```{r, echo = F}
options("getSymbols.warning4.0"=FALSE)
```


```{r}
getSymbols("^IXIC",from="2012-01-01", to="2022-03-01", warnings = F) 
dim(IXIC)         # <=== find the size of the data downloaded
#write.csv(IXIC, file = "IXIC.csv", row.names = F)
#data <- read.csv2("IXIC.csv")

# Want the adjusted closed data.
ixic <- IXIC[,6]
```

The data does not have any NA values (Weekends and holidays have been removed already), we can start working with the data directly. 

```{r, echo = F}
plot(ixic)
```

COMMENT: DRAW SOME HAPPENINGS IN THE SERIES (Covid March 2020 and Russia-Ukraine in Feb 2022 + leading up to Feb in the beginning of 2022). Did something happen in Jan 2019 in the US (with tech-companies?) Did something happen in Jan 2016 (small regression).


## Analysis of Stationarity
In order to see if the series is stationary, we will employ both informal and formal tests. Immediately, by looking at the plot above (reference later), the series does not look stationary, since the mean of the process looks to change quite dramatically with time. Some more informal tests are done. The function of autocorrelation and partial autocorrelation (empirical) for the series are plotted below. 

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1) 
acf(ixic,ylim=c(-1,1),main="ixic")
pacf(ixic,ylim=c(-1,1),main="ixic")
```

As is seen from the function of autocorrelation (ACF), the coefficients decrease slowly. This suggests that the time series is non-stationary, since a stationary series would show exponentially decreasing coefficients in the ACF. 

SJEKK AT ALT DETTE GIR MENING (OG BRUKER KORREKTE BEGREPER) SENERE! (TIL SLUTT)

Next, some Ljung-Box tests are done. Here we are testing the joint hypothesis that all $m$ of the correlation coefficients are simultaneously equal to zero. Below we are testing for $m \in \{1, 5, 10, 15, 20\}$. 

MAKE A SUMMARY-TABLE HERE INSTEAD LATER! JUST SHOW THE LAGS AND THE P-VALUES.

```{r}
Box.test(ixic, lag = 1, type = c("Ljung-Box"))
Box.test(ixic, lag = 5, type = c("Ljung-Box"))
Box.test(ixic, lag = 10, type = c("Ljung-Box"))
Box.test(ixic, lag = 15, type = c("Ljung-Box"))
Box.test(ixic, lag = 20, type = c("Ljung-Box"))
```

All the $p$-values from the Ljung-Box tests are low, which means that we would reject the null hypothesis that all $m$ correlation coefficients are simultaneously equal to zero. This further suggests that the series is non-stationary.

Next, some formal tests are done to check stationarity of the series. First, the Augmented-Dickey-Fuller (ADF) unit root test is done. The null hypothesis for this case states that the series is integrated of order 1, i.e. that it is non-stationary. Below, the ADF test is done assuming both a stochastic and deterministic trend in the data. The maximum number of lags considered are 20 and the number of lags used are chosen by BIC. 

```{r}
ixic.df<-ur.df(ixic, type = c("trend"), lags=20, selectlags = c("BIC"))
summary(ixic.df)	
```

From the output it is apparent that BIC chooses 9 lags in the DF test. Moreover, the value of the test-statistic clearly suggests that we cannot reject the null-hypothesis, since the value is much larger than the critical values for this left-sided test. Thus, we would conclude that the series is non-stationary. Note that the test leads to the same conclusion when assuming no trends and when assuming only a drift. Moreover, the same amount of lags are chosen for all three variants. Below, the residuals and the autocorrelation functions of the residuals are plotted, in order to check if the number of lags chosen via BIC is satisfactory. 

```{r}
plot(ixic.df)
```

The autocorrelation function of the residuals has no significant coefficients, which leads us to conclude that the amount of lags chosen via BIC is satisfactory. 

Next, we check if the returns (rendimientos) are stationary. Below we calculate the returns and remove the first difference, since it is not a numerical value. 

```{r}
rendixic <- diff(log(ixic))
rendixic <- rendixic[-1] # The first difference is NA, needs to be removed. 
```

```{r}
plot(rendixic)
```

Then, the ADF test is calculated without trends, since there does not look to be any trends in the plot of the returns. Note that, as earlier, the conclusion of the test and the amount of lags that are chosen via BIC are the same when assuming a drift or both types of trends.

```{r}
rendixic.df<-ur.df(rendixic, type = c("none"), lags=20, selectlags = c("BIC"))
summary(rendixic.df)	
```

It is apparent that 8 lags are chosen. Moreover, from the test-statistic above we would reject the null-hypothesis, which means that we have found evidence against the hypothesis that the returns are $I(1)$, i.e. evidence against the hypothesis that the original series is $I(0)$. Thus, we conclude that the returns are $I(0)$ or the original series is $I(1)$. This means that, through the results from this test, the original series is not stationary (which we have seen earlier), but the returns are stationary and can be used further in the analysis. SJEKK AT DET JEG SKRIVER HER STEMMER, TROR DET GJØR DET! HAR NOEN NOTATER FRA ET EKSEMPEL PÅ TAVLA PÅ DETTE!

As earlier, the plot below shows that the amount of lags for the ADF test chosen via BIC is satisfactory. 

```{r}
plot(rendixic.df)
```

For completeness, we also use the Philips-Perron (PP) test to check stationarity of the series. This test defines the same null-hypothesis as the ADF test, which means that this is a left-tailed test as well. 
COULD MAKE A TABLE FROM THESE TWO LAST TESTS (WITH THE MOST IMPORTANT STATISTICS), TO SAVE SOME ROOM IF NEEDED, SINCE THE CONCLUSIONS ARE THE SAME AS EARLIER (AS EXPECTED).

```{r}
ixic.pp<-ur.pp(ixic, type = c("Z-tau"), model = c("trend"), lags = c("long"))
summary(ixic.pp)	
```

All combinations of trend assumptions and/or long or short lags yield the same conclusions as from the output above; namely that we have not found sufficient evidence to reject the null-hypothesis of non-stationarity of the series. Below the PP-test is done with the returns. 
```{r}
rendixic.pp<-ur.pp(rendixic, type = c("Z-tau"), model = c("constant"), lags = c("short"))
summary(rendixic.pp)	
```

When referring to the returns, the conclusion is the same as for the ADF test; the returns are stationary while the original series is not. 

Finally, we use the KPSS test to check stationarity of the series. The null hypothesis for this test states that the series is stationary. In the test below we have chosen to assume the deterministic component as a constant with a linear trend, and we have used short lags. Note that the conclusion is the same with all different variations of assumptions for the test. 

```{r}
ixic.kpss<-ur.kpss(ixic, type = c("tau"), lags = c("short"))
summary(ixic.kpss)
```

Since this is a right-tailed test, the test-statistic is clearly sufficiently large to reject the null-hypothesis to the lowest significance level shown (0.01). Thus, we conclude that the series is non-stationary, as expected. The test below shows that the returns are stationary, in line with what we have concluded earlier, since we cannot find strong evidence against the null-hypothesis. 

```{r}
rendixic.kpss <- ur.kpss(rendixic, type = c("mu"), lags = c("short"))
summary(rendixic.kpss)
```

Conclusively, the original time series is not stationary, but the returns are stationary, which means that the returns will be used in the following analysis. We can be relatively certain that this is the case, since all three formal tests, as well as the informal tests, point to this conclusion. 

## Basic Statistical Properties of the Stationary Series

Some basic statistical properties of the stationary series, the returns, are shown below. 

```{r}
basicStats(rendixic)
```

```{r, echo = F}
hist(rendixic,breaks=100,freq=F, main = 'Histogram of the Returns')
curve(dnorm(x, mean=mean(rendixic), sd=sd(rendixic)), col=2, add=T)
```

We can see that the series is Leptokurtic, both by the kurtosis value and from the histogram above. The superposed red curve is a Gaussian distribution with empirical mean and standard error according to the returns of the NASDAQ Composite series. Moreover, the skewness is negative, which means that the distribution of the returns are heavy-tailed in the left tail. This is also apparent from the histogram above. 

## Identification, Estimation and Diagnostics of a Model for the Mean

Plotting the autocorrelation functions of the returns. 

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
acf(rendixic,ylim=c(-1,1),main="rendixic")
pacf(rendixic,ylim=c(-1,1),main="rendixic")
```

It looks like both the ACF and the partial ACF (PACF) have 9 significant coefficients. This seems like a large order of ARMA-model to estimate, so I will try with smaller models instead. Note that the third coefficient of both ACF and PACF seems to be non-significant, which might be a hint to what order of model would be fitting. The table below shows the BIC and the AIC for different orders of ARMA-models. 

```{r, echo = F, results='hide'}
#ar(1)
model = arima(rendixic, order = c(1,0,0),include.mean = TRUE)
model$aic
BIC(model)
pnorm(c(abs(model$coef)/sqrt(diag(model$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#ma(1)
model2 = arima(rendixic, order = c(0,0,1),include.mean = TRUE)
model2 
pnorm(c(abs(model2$coef)/sqrt(diag(model2$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#arma(1,1) 
model3 = arima(rendixic, order = c(1,0,1),include.mean = TRUE)
model3 
pnorm(c(abs(model3$coef)/sqrt(diag(model3$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#ar(2) 
model4 = arima(rendixic, order = c(2,0,0),include.mean = TRUE)
model4 
pnorm(c(abs(model4$coef)/sqrt(diag(model4$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#MA(2) 
model5 = arima(rendixic, order = c(0,0,2),include.mean = TRUE)
model5 
pnorm(c(abs(model5$coef)/sqrt(diag(model5$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#arma(2,2)
model6 <- arima(rendixic, order = c(2,0,2),include.mean = TRUE)
model6
pnorm(c(abs(model6$coef)/sqrt(diag(model6$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#AR(3)
model7 <- arima(rendixic, order = c(3,0,0),include.mean = TRUE)
model7
pnorm(c(abs(model7$coef)/sqrt(diag(model7$var.coef))), mean=0, sd=1, lower.tail=FALSE)

#MA(3)
model8 <- arima(rendixic, order = c(0,0,3),include.mean = TRUE)
model8
pnorm(c(abs(model8$coef)/sqrt(diag(model8$var.coef))), mean=0, sd=1, lower.tail=FALSE)
```

Note that all models we have estimated here have significant coefficient estimates to a predetermined significance level of $\alpha = 0.05$.

```{r, echo = F}
models <- c("AR(1)", "MA(1)", "ARMA(1,1)", "AR(2)", "MA(2)", "ARMA(2,2)", "AR(3)", "MA(3)") 
bics <- c(model$aic, model2$aic, model3$aic, model4$aic, model5$aic, model6$aic, model7$aic, model8$aic)
aics <- c(BIC(model), BIC(model2), BIC(model3), BIC(model4), BIC(model5), BIC(model6), BIC(model7), BIC(model8))
df.arma <- cbind("Model" = models, "BIC" = bics, "AIC" = aics)
knitr::kable(df.arma, caption = "AIC and BIC of different estimated models for the returns of NASDAQ Composite")
```

The table above clearly shows that ARMA(2,2) yields the lowest AIC and BIC. Moreover, as noted, the estimated coefficients of the model are significant to a level of $0.05$. The estimated model ARMA(2,2) is shown below

```{r}
mean.model <- arima(rendixic, order = c(2,0,2),include.mean = TRUE)
mean.model
pnorm(c(abs(mean.model$coef)/sqrt(diag(mean.model$var.coef))), mean=0, sd=1, lower.tail=FALSE)
```

Some model diagnostics have to be done to check if the model is adequate. We must check if the model is stationary. 

```{r}
plot(mean.model)
```

The inverse roots of the characteristic polynomial of AR and MA are shows above. DO WE WANT ALL OF THE INVERSE ROOTS TO FALL INSIDE, FOR BOTH THE AR AND THE MA PROCESS? The stationarity condition for the AR-process is satisfied, since the roots have absolute values greater than one. Moreover, the invertibility condition holds for the MA process, since the roots of this process also have absolute values greater than one. Thus, the model is stationary. 

The residuals of the model are analyzed below. 

```{r}
tsdiag(mean.model)
```

There are no significant coefficients in the autocorrelation function above, which suggests that the model has adequately captured the information in the data. Moreover, the Ljung-Box statistic p-values are all relatively large, which means that we will not reject the Ljung-Box null hypothesis that all $m$ of the correlation coefficients are simultaneously equal to zero. Thus, this further suggests that the residuals are not correlated and we have found a model that seems reasonable in this regard. 

Next, a QQ-plot of the residuals, and the residuals themselves (not standardized), is plotted.

```{r}
par(mfrow = c(1,1),font=2,font.lab=4,font.axis=2,las=1)
qqnorm(mean.model$residuals)
qqline(mean.model$residuals, datax = FALSE)

plot(mean.model$residuals)
title (main="Residuals")
normalTest(mean.model$residuals,method="jb")
```

It is apparent that the residuals have heavy tails. It is not reasonable to assume normality of the residuals, an argument that the Jarque-Bera Normality test further substantiates because its null hypothesis of normality is rejected following the very small p-value. 

## Identification, Estimation and Diagnostics of a Model for the Variance

First we test for ARCH effects using the residuals of the mean model. 

```{r}
residuals <- mean.model$residuals
residuals2 <- residuals^2

par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
acf(residuals2,ylim=c(-1,1),main="Squared Residuals") 
pacf(residuals2,ylim=c(-1,1),main="Squared Residuals")
par(mfrow=c(1,1))
# Har acf ovenfor noe sammenheng med plottet nedenfor (se slides 33++ i Volatility Models)?
# For de ser veldig like ut. Men vet ikke helt om residuals^2 fra modellen har noe med dette å gjøre?
# Mulig det er fordi vi estimerer mean vha ARMA-modellen og trekker den fra + kvadrat, noe vi egt gjør direkte fra serien nedenfor!?
acf((rendixic-mean(rendixic))^2, ylim = c(-1,1))

Box.test(residuals2,lag=1,type='Ljung')
Box.test(residuals2,lag=5,type='Ljung')
Box.test(residuals2,lag=15,type='Ljung')
```

As seen in the ACF and PACF of the squared residuals, they are clearly presenting autocorrelation, i.e. there are ARCH effects present. This argument is further substantiated by the Ljung-Box tests above, since they lead to the conclusion that the squared residuals are correlated. Thus, it is relevant to identify and estimate a model for the volatility. Joint estimation of the mean and volatility equations, for different types of models, is done in the following. 

Now over to estimation of GARCH models for the variance of the returns. First we estimate a ARMA(2,2)-GARCH(1,1) with a t-student distribution. WHY CHOSE A T-STUDENT OVER A NORMAL (OR VICE VERSA)?

```{r}
spec1 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)), mean.model=list(armaOrder=c(2,2)), distribution.model = "std")
(m <- ugarchfit(spec = spec1, data = rendixic))
m.AIC <- -6.4605
```

We observe that all the parameter estimates are significant to a 5\% significance level. Moreover, we note that the condition of positivity holds, because $\hat{\alpha}_1 > 0$ and $\hat{\beta}_1 > 0$, where we follow the standard statistical notation of a hat indicating an estimate. Also, we note that the condition of stationarity holds, because $\hat{\alpha}_1 + \hat{\beta}_1 < 1$. We record the AIC of this first model in order to compare to other models later. The residual plots below show that the residuals do not present any autocorrelation (before moving to around 15 lags, which is a large number of lags), which indicates that this model has modeled the data in a sufficient or reasonable way. However, note that the p-values of the `Weighted Ljung-Box Test on Residuals` are large, which means we cannot reject the null hypothesis of no serial correlation for the different lags. We will keep this is mind as a downfall of this first proposed model. 

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
plot(m, which = 10)
plot(m, which = 11)
```

<!-- The estimated volatilities from this first model, together with the returns, are shown in the plots below. The general behaviour seems to match relatively well, i.e. the movements in the two plots coincide relatively well.  -->

<!-- ```{r} -->
<!-- par(mfcol=c(2,1))  # Show volatility and returns simultaneously. -->
<!-- plot(v_anualized) -->
<!-- plot(rendixic)  -->
<!-- ``` -->

Next we will fit a ARMA(2,2)-GJR-GARCH(1,1) model, assuming a t-distribution. 

```{r}
spec.mgjr <- ugarchspec(variance.model=list(model="gjrGARCH", garchOrder = c(1,1)), mean.model=list(armaOrder=c(2,2)), distribution.model = "std")
(mgjr <- ugarchfit(spec = spec.mgjr, data = rendixic))
```

The stationarity conditions holds, since $\hat{\alpha}_1 + \hat{\beta}_1 + \frac12 \hat{\gamma} \approx$ `r round(0.823974 + 0.5*0.260477, 3)` $<1$. However, the positivity condition does not seem to hold, since $\hat{\alpha} = 0 \ngeq 0$. Thus, the GJR-GARCH based model will not be used, even though the AIC is lower and the residuals do not present any autocorrelation according to plots. Moreover, the several of the ARMA-parameter coefficient estimates are not significant to a reasonable level, which is the case no matter what `armaOrder` is use in the estimation. 

<!-- The residuals for the second model are plotted below.  -->

<!-- ```{r} -->
<!-- par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1) -->
<!-- plot(mgjr, which = 10) -->
<!-- plot(mgjr, which = 11) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- vgjr <- sigma(mgjr) # Estimated volatility.  -->
<!-- vgjr_anualized <- (250)^0.5*vgjr -->
<!-- par(mfcol=c(2,1)) -->
<!-- plot(vgjr_anualized) -->
<!-- plot(rendixic)  -->
<!-- ``` -->

Next, we will fit an ARMA(2,2)-EGARCH model. 
 
```{r}
spec.egarch <- ugarchspec(variance.model = list(model="eGARCH", garchOrder = c(1,1)), mean.model = list(armaOrder=c(2,2)), distribution.model = "std")
(m.egarch <- ugarchfit(spec = spec.egarch, data = rendixic))
m.egarch.AIC <- -6.4958
```

All estimated parameters are significant to a level of $\alpha = 0.05$. For this model, we do not require positivity of the GARCH parameter estimates. WHAT ABOUT STATIONARITY, DO WE REQUIRE THIS? The residual plots below do not show any autocorrelation before moving to a large number of lags, which is a good sign that the model has modelized the data adequately. Moreover, the AIC is smaller for this model compared to the first proposed model. Thus, I would prefer this model over the first model. Note that $\gamma > 0$, which should mean that the positive news have a larger effect on the news compared to the negative news, which does not make sense here, when looking at the news impact curve. THIS IS STRANGE, I DO NOT UNDERSTAND THIS!? ASK PROFE!

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
plot(m.egarch, which = 10)
plot(m.egarch, which = 11)
par(mfrow=c(1,1),font=2,font.lab=4,font.axis=2,las=1)
plot(m.egarch, which = 12)
```

Next, we fit and ARMA(2,2)-IGARCH model. 

```{r}
spec.igarch <- ugarchspec(variance.model=list(model="iGARCH", garchOrder = c(1,1)), mean.model=list(armaOrder=c(2,2)), distribution.model = "std")
(m.igarch <- ugarchfit(spec=spec.igarch,data=rendixic))
m.igarch.AIC <- -6.4602
```

The residuals for the iGARCH look alright, but the AIC is lower for the EGARCH based model. 

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
plot(m.igarch, which = 10)
plot(m.igarch, which = 11)
```

Thus, I would conclude that the best model out of the three fitted is the EGARCH based model. 

# Grafic and Interpretation of the Estimated Series of Volatility

The estimated (anualized) series of volatility for the ARMA(2,2)-EGARCH model is shown below, together with the returns. 

```{r}
v <- sigma(m.egarch) 
v_anualized <- (250)^0.5*v
par(mfcol=c(2,1))  # Show volatility and returns simultaneously.
plot(v_anualized)
plot(rendixic) 
```

The general behaviour seems to match relatively well, i.e. the movements in the two plots coincide relatively well. Days with larger (absolute) returns go together with the days with larger estimated volatilities. 

A comparison of the estimated volatilities and the absolute value of the returns is given below. 

```{r}
returnsabs <- abs(rendixic)
par(mfrow=c(2,1),font=2,font.lab=4,font.axis=2,las=1)  # Show volatility and returns
plot(v_anualized)
plot(returnsabs) 
```

They all seem to follow a similar pattern, which is a good sign, even though we cannot compare the absolute values of the data shown in the plots. 

```{r}
par(mfrow=c(1,1),font=2,font.lab=4,font.axis=2,las=1)
time <-  data.frame(returnsabs, v)
ts.plot(time,gpars= list(xlab="time", ylab=",", col = 1:ncol(time)))
legend("topleft", c("returnsabs","v"), lty=c(1,1), col=c("black","red"), cex=0.6)
```

THESE ARE ALL JUST DIFFERENT WAYS OF SEEING THE SAME RESULTS, REMOVE SOME OF THEM LATER!

# Grafic and Interpretation of the News Impact Curve

The news impact curve for our chosen model is shown below. Since the standard GARCH model does not take the leverage effect into effect, the news impact curve is symmetric. 

```{r}
par(mfrow=c(1,2),font=2,font.lab=4,font.axis=2,las=1)
nie <- newsimpact(z = NULL, m.egarch)
plot(nie$zx, nie$zy, ylab=nie$yexpr, xlab=nie$xexpr, type="l", main = "News Impact Curve")
ni <- newsimpact(z = NULL, m)
plot(ni$zx, ni$zy, ylab=ni$yexpr, xlab=ni$xexpr, type="l", main = "News Impact Curve")
```

The EGARCH based model takes the leverage effect into effect, which is the news impact curve is non-symmetric. This curve indicates that the volatility is impacted to a higher degree by negative news compared to the impact on the volatility following positive news, which seems to be increasingly small as the positivity of the news increases THIS IS VERY STRANGE!!

# Volatility Predictions and Interpretations

Below volatility are predicted while leaving out the last 10 observations when estimating the ARMA(2,2)-EGARCH model. The prediction is done 10 steps ahead into the future, first statically. 

```{r}
(m.egarch.pred <- ugarchfit(spec = spec.egarch, data = rendixic, out.sample = 10))
forc <- ugarchforecast(m.egarch.pred, n.ahead=10, n.roll= 0) 
#show(forc)
#fpm(forc)

par(mfrow=c(2,1),font=2,font.lab=4,font.axis=2,las=1)
plot(forc, which = 1)
plot(forc, which = 3)
uncvariance(m.egarch.pred)^0.5
```

As we can see from the uppermost plot, these static predictions (for the mean) 10 steps ahead are relatively useless. ALSO LOOKS LIKE THE FORECAST OF THE VARIANCE WILL GO TOWARDS THE UNCONDITIONAL VARIANCE. NOT SURE IN WHAT SITUATIONS THIS SHOULD HAPPEN THOUGH, ASK PROFE PERHAPS!

Next, let us predict 10 steps into the future with a rolling window. We reestimate the model at each time step and estimate one step into the future after each reestimation. After doing this 10 times, we have effectively predicted 10 days into the future. 

```{r}
forc2 <- ugarchforecast(m.egarch.pred, n.ahead=1, n.roll= 10)
#fpm(forc2)
#sigma(forc2) 
#fitted(forc2)

par(mfrow=c(2,1),font=2,font.lab=4,font.axis=2,las=1)
plot(forc2, which = 2)
plot(forc2, which = 4)
```

The predictions are still lousy, as can be seen from the predictions of the mean in the uppermost plot. However, from the second plot, it looks like the predictions of the variance are somewhat following the same movements as the absolute value of the series; when the absolute value of the series hits a spike, the predictions of the volatility increase as well. 

The same type of movement can be seen when predicting with a rolling window 100 steps into the future, where the results of this prediction is shown below. 

```{r}
(m.egarch.pred2 <- ugarchfit(spec = spec.egarch, data = rendixic, out.sample = 100))
forc3 <- ugarchforecast(m.egarch.pred2, n.ahead=1, n.roll= 100)
#fpm(forc3)
#sigma(forc3) 
#fitted(forc3)

par(mfrow=c(2,1),font=2,font.lab=4,font.axis=2,las=1)
plot(forc3, which = 2)
plot(forc3, which = 4)
```

# Calculations via Historical Volatility and EWMA

Historical volatility is calculated below. The historical volatility has been calculated using Simple Moving Average (SMA) over different time periods

$$
\sigma_t^2 = \frac1k\sum_{i=1}^kr_{t-1}^2.
$$

```{r}
par(mfrow=c(1,1),font=2,font.lab=4,font.axis=2,las=1)
Fechas<-as.Date(rownames(zoo(IXIC)))
Fechas<-Fechas[-1] # Eliminate the first date, since it was lost when calculating returns. 

vol.hist20 <- SMA(rendixic^2, n=20) 
Fechas2<-Fechas[21:2556] 
#plot(Fechas2, vol.hist20, type="l", ylab='variance', xlab="time", main='1 month moving average')

vol.hist80 <- SMA(rendixic^2, n=80) 
Fechas3<-Fechas[81:2556]
#plot(Fechas3, vol.hist80, type="l", ylab='variance', xlab="time",main='4 month moving average')

vol.hist160 <- SMA(rendixic^2, n=160) 
Fechas4<-Fechas[161:2556]
#plot(Fechas4, vol.hist160, type="l", ylab='variance', xlab="time",main='8 month moving average')

vol.hist240 <- SMA(rendixic^2, n=240) 
Fechas5<-Fechas[241:2556]
#plot(Fechas5, vol.hist240, type="l", ylab='variance', xlab="time",main='1 year moving average')
 
par(mfrow=c(2,2), cex=0.6, mar=c(2,2,3,1))
plot(Fechas2, vol.hist20, type="l", ylab='variance', xlab="time", main='1 month moving average')
plot(Fechas3, vol.hist80, type="l", ylab='variance', xlab="time", main='4 month moving average')
plot(Fechas4, vol.hist160, type="l", ylab='variance', xlab="time", main='8 month moving average')
plot(Fechas5, vol.hist240, type="l", ylab='variance', xlab="time", main='1 year moving average')
```

As is apparent from the plots, the volatility pattern is highly dependent on the $k$, i.e. the number of observations used to calculate the moving average. Moreover, we can see that the results are greatly affected by extreme values, especially when $k$ is small, which is clearly seen in the results for the 1 month moving average. The volatility pattern is smoother when $k$ is larger. Which of these values for $k$ gives the "best" results? This is difficult to answer. 

The Exponentially Weighted Moving Average (EWMA) model is used to calculate volatility

$$
\sigma_t^2 = (1-\lambda)r_{t-1}^2 + \lambda\sigma_{t-1}^2 = (1-\lambda) \sum_{i = 1}^\infty\lambda^{i-1}r_{t-1}^2, \hspace{0.5em} 0<\lambda<1.
$$

Different values of the parameter $\lambda$ are used in order to see how the results depend on it. From the theoretical point of view, we know that the term $(1-\lambda)r_{t-1}^2$ determines the reaction of volatility to market events, i.e. the larger the term $(1-\lambda)$ the larger the reaction in the volatility stemming from yesterday's return. Moreover, the term $\lambda\sigma_{t-1}^2$ determines the persistence in volatility. In other terms, it decides how much of yesterday's volatility is allowed to persist to today's volatility: A larger value of $\lambda$ gives larger persistence. Thus, the EWMA model gives a trade-off between persistence and reaction in the volatility, depending on the value of $\lambda$. 

```{r}
vol.ewma0.95 <- EWMA(rendixic^2, lambda = 0.05) # note: in EWMA lambda is actually 1-lambda
#plot(Fechas, vol.ewma0.95, type="l", ylab='variance', xlab = "time", main='EWMA 0.95')

vol.ewma0.75 <- EWMA(rendixic^2, lambda = 0.25) # note: in EWMA lambda is actually 1-lambda
#plot(Fechas, vol.ewma0.75, type="l", ylab='variance', xlab = "time", main='EWMA 0.75')

vol.ewma0.5 <- EWMA(rendixic^2, lambda = 0.5) # note: in EWMA lambda is actually 1-lambda
#plot(Fechas, vol.ewma0.5, type="l", ylab='variance', xlab = "time", main='EWMA 0.5')

vol.ewma0.25 <- EWMA(rendixic^2, lambda = 0.75) # note: in EWMA lambda is actually 1-lambda
#plot(Fechas, vol.ewma0.25, type="l", ylab='variance', xlab = "time", main='EWMA 0.25')

par(mfrow=c(2,2), cex=0.6, mar=c(2,2,3,1))
plot(Fechas, vol.ewma0.95, type="l", ylab='variance', main=TeX(r'(EWMA, $\lambda = 0.95$)', bold = TRUE))
plot(Fechas, vol.ewma0.75, type="l", ylab='variance', main=TeX(r'(EWMA, $\lambda = 0.75$)', bold = TRUE))
plot(Fechas, vol.ewma0.5, type="l", ylab='variance', main=TeX(r'(EWMA, $\lambda = 0.5$)', bold = TRUE))
plot(Fechas, vol.ewma0.25, type="l", ylab='variance', main=TeX(r'(EWMA, $\lambda = 0.25$)', bold = TRUE))
```

As we can see from the plots above, the larger values of $\lambda$ give smoother plots, since the persistence is larger, while the smaller values of $\lambda$ give a more reactive or non-smooth volatility pattern, since the persistence of the volatility is much lower in these cases. Comparing to the results obtained when using the historical volatility, all the volatility patterns obtained with EWMA are more non-smooth than the former, being most similar to the 1 month moving average. Note also that the choice of $\lambda$ seems somewhat arbitrary in this case (similar to the choice of $k$ for historical volatility), as it is difficult to be certain about the best choice of the parameter. 

Doing a quick comparison between these two models and the results from the EGARCH model, it looks like the EWMA model with $\lambda = 0.75$ gives a relatively similar volatility pattern, whereas the 1 month moving average (which is the one among the four models that is most similar to the results from EGARCH) is lacking in comparison. 

```{r}
par(mfrow=c(1,1), cex=0.6, mar=c(2,2,3,1))
variance <- v^2
comparison <- data.frame(variance, vol.ewma0.75)
ts.plot(comparison,gpars= list(ylab=",", col = 1:ncol(comparison), xaxt = "n"))
legend("topleft", c("E-GARCH",TeX(r'(EWMA, $\lambda = 0.75$)')), lty=c(1,1), col=c("black","red"))
axis(1, at=1:6)#, labels=c(2012, 2014, 2016, 2018, 2020, 2022))

variance2 <- variance[21:2555]
volhist <- vol.hist20[1:2535]
comparison <- data.frame(variance2, volhist)
ts.plot(comparison,gpars= list(ylab=",", col = 1:ncol(comparison), xaxt = "n"))
legend("topleft", c("E-GARCH","1 month moving average"), lty=c(1,1), col=c("black","red"))
axis(1, at=1:6)#, labels=c(2012, 2014, 2016, 2018, 2020, 2022))
```

NOTE THAT THE TIMES ON THE X-AXIS ARE FUCKED UP. TRY TO FIX THIS LATER!

# Calculation and Interpretation of VaR 

Here we will calculate and interpret the Value at Risk (VaR) using estimated volatilities from several different models. First we use the variance-covariance method, calculating the VaR with a static forecast 1 ahead, using the EGARCH model. Remember that this was the first type of forecast we did in section 6. 

```{r VaR, cache = T}
# Calculating VaR based on the first type of prediction, without rolling window.
forc <- ugarchforecast(m.egarch, n.ahead=1, n.roll= 0)
show(forc)
var5.garch <- - qnorm(0.95) * 0.01791
show(var5.garch)
```

This value means that, with a confidence level of $95\%$, the largest expected loss for tomorrow in our index is $\approx 2.95 \%$. In other terms, the probability of the return tomorrow being lower than $-2.95\%$ is $5\%$. 

Next we calculate the VaR with a rolling window dynamic forecast, using the EGARCH model, with a sinificance level of $5\%$.

```{r, cache = T}
# Calculating VaR based on the second type of prediction, with rolling window. 
var.t <-  ugarchroll(spec.egarch, data = rendixic, n.ahead = 1, forecast.length = 50, refit.every = 10,  refit.window = "rolling",
                   calculate.VaR = TRUE, VaR.alpha = 0.05)
plot(var.t, which = 4, VaR.alpha = 0.05)
report(var.t, VaR.alpha = 0.05)
```

The report above shows that our set level of $5\%$ significance is not kept, i.e. that the largest expected loss cannot be quantified at the $5\%$ significance level. Instead, the VaR is estimated to be $14\%$, which means that the probability of the return the next day being lower than the VaR is $ \approx 14\%$ instead of $5\%$. In practice, this means that the company should set aside more funds than expected, in order to cover the significance level of $5\%$. 

LITT USIKKER PÅ DENNE TOLKNINGEN!

Next, we calculate the VaR using an EWMA model with $\lambda = 0.75$. 

```{r ewma/VaR, cache = T}
# With EWMA calculated with lambda=0.75
var5.ewma  <-  - qnorm(0.95) * sqrt(vol.ewma0.75)
var5.egarch <- - qnorm(0.95) * (v)
var1.ewma  <-  - qnorm(0.99) * sqrt(vol.ewma0.75)
var1.egarch <-  - qnorm(0.99) * v


par(mfrow=c(2,2), cex=0.6, mar=c(2,2,3,1))
plot(Fechas, rendixic,type="l", main ="5% VaR EWMA")
lines(Fechas, var5.ewma, col = "blue")
plot(Fechas, rendixic,type="l", main ="5% VaR E-GARCH(1,1)")
lines(Fechas,var5.egarch, col ="blue")
plot(Fechas, rendixic,type="l", main ="1% VaR EWMA")
lines(Fechas, var1.ewma, col = "red")
plot(Fechas, rendixic, type="l", main ="1% VaR E-GARCH(1,1)")
lines(Fechas, var1.egarch, col ="red")
```

HVA ER DETTE?

```{r, eval = F}
# Copied from aplication_VaR_2022.R
#calculate the fraction of sample where loss exceed both 1% and 5% VaR for EWMA and GjR-GARCH(1,1)
sum(rendibex < var5.ewma)/length(rendibex) # fraction of sample where loss exceeds 5% VaR for EWMA

sum(rendibex < var5.gjrgarch)/length(rendibex) # fraction of sample where loss exceeds 5% VaR for gjrGARCH(1,1)

sum(rendibex < var1.ewma)/length(rendibex) # fraction of sample where loss exceeds 1% VaR for EWMA

sum(rendibex < var1.gjrgarch)/length(rendibex) # fraction of sample where loss exceeds 1% VaR for gjrGARCH(1,1)
# vemos que es parecido o igual en ambos casos (con lambda=0.95)

#con EWMA calculada CON LAMBDA=0.75
vol.ewma0.75 <- EWMA(rendibex^2, lambda = 0.25) # note: in EWMA lambda is actually 1-lambda

var5.ewma  <-  - qnorm(0.95) * sqrt(vol.ewma0.75)
var5.gjrgarch <-  - qnorm(0.95) * (v)
var1.ewma  <-  - qnorm(0.99) * sqrt(vol.ewma0.75)
var1.gjrgarch <-  - qnorm(0.99) * v

par(mfrow=c(2,2), cex=0.6, mar=c(2,2,3,1))
plot(Fechas, rendibex,type="l", main ="5% VaR EWMA")
lines(Fechas, var5.ewma, col = "blue")
plot(Fechas, rendibex,type="l", main ="5% VaR GJR-GARCH(1,1)")
lines(Fechas, var5.gjrgarch, col ="blue")
plot(Fechas, rendibex,type="l", main ="1% VaR EWMA")
lines(Fechas, var1.ewma, col = "red")
plot(Fechas, rendibex, type="l", main ="1% VaR GJR-GARCH(1,1)")
lines(Fechas, var1.gjrgarch, col ="red")

#es m?s suave el VaR calculado con GJR-Garch 

#calculate the fraction of sample where loss exceed both 1% and 5% VaR for EWMA and GJRGARCH(1,1)
sum(rendibex < var5.ewma)/length(rendibex) # fraction of sample where loss exceeds 5% VaR for EWMA

sum(rendibex < var5.gjrgarch)/length(rendibex) # fraction of sample where loss exceeds 5% VaR for gjrGARCH(1,1)

sum(rendibex < var1.ewma)/length(rendibex) # fraction of sample where loss exceeds 1% VaR for EWMA

sum(rendibex < var1.gjrgarch)/length(rendibex) # fraction of sample where loss exceeds 1% VaR for gjrGARCH(1,1)

#?COMO ELEGIMOS LAMBDA? CON GARCH LOS DATOS HABLAN
#Ewma con lambda 0.75 sobreestima el riesgo y la compa?ia estar?a dedicando demasiados recursos al capital regulatorio m?nimo.
```


HVORFOR IKKE FORECASTS SOM BLIR BRUKT HER?

# Multivariate DCC

In order to solve this problem I have chosen the stock of Stratus Properties Inc. (STRS), which is one of the [top 30 components](https://finance.yahoo.com/quote/%5EIXIC/components?p=%5EIXIC) of the NASDAQ Composite Index. 

```{r}
# Get STRS stock data and redo analysis for this stock. 
STRS <- read.csv("STRS.csv")
head(STRS)
any(is.na(STRS))
str(STRS)
strs <- STRS[,6]
head(strs)

date <- as.Date(STRS$Date,"%d/%m/%Y")  

# Gr?fico de la serie temporal
#plot(date, strs,type="l",col="blue", main="Prices")
#legend("bottomleft", c("Austria","Grecia"), lty=c(1,1), col=c("blue","red"))
```


# News Impact Surface and Estimated Correlation 

# Conclusions 
